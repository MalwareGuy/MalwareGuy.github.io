<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.9.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2023-01-24T16:01:45+00:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Malware Guy</title><subtitle>The website housing the endeavors and thoughts of a malware-hunting VTuber.</subtitle><author><name>Malware Guy</name></author><entry><title type="html">The Curious Case of MPNotify &amp;amp; NPPSPY</title><link href="http://localhost:4000/Hunts/nppspy.html" rel="alternate" type="text/html" title="The Curious Case of MPNotify &amp;amp; NPPSPY" /><published>2023-01-20T00:00:00+00:00</published><updated>2023-01-20T00:00:00+00:00</updated><id>http://localhost:4000/Hunts/NPPSPY</id><content type="html" xml:base="http://localhost:4000/Hunts/nppspy.html">&lt;p&gt;Today’s hunt was inspired from this awesome &lt;a href=&quot;https://www.huntress.com/blog/cleartext-shenanigans-gifting-user-passwords-to-adversaries-with-nppspy&quot;&gt;blog&lt;/a&gt; by &lt;a href=&quot;https://twitter.com/Purp1eW0lf&quot;&gt;Dray Agha&lt;/a&gt;! Also a special thanks to &lt;a href=&quot;https://twitter.com/robsware?t=priHMGg-KwSi-uAEMpN-zw&amp;amp;s=0&quot;&gt;Robsware&lt;/a&gt; for taking the time out his day to proofread this post! Bug, bother, nudge - show those two horrendously cool blokes all the love you can muster and ask them all about their expert knowledge on &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;lsass.dll&lt;/code&gt;!&lt;/p&gt;

&lt;figure class=&quot;align-center&quot; style=&quot;width: 666px&quot;&gt;
    &lt;img src=&quot;/assets/images/nppspy/shaggy.png&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;I’ve been absolutely &lt;strong&gt;brimming&lt;/strong&gt; with excitement to release this blog post! In this hunt I covered a thorough analysis of a custom NPPSPY specimen, from loading it inside IDA Home and reproducing the attack to writing detection rules, although what was most important to me was taking on some challenges and learning a few new things along the way on and off-stream. Throughout the time you’re reading, be sure to tap or click the images to zoom in!&lt;/p&gt;

&lt;p&gt;As described within the investigation post from Huntress, the original NPPSPY tool was capable of abusing the relationship between WinLogon and Local Security Authority Subsystem Service (LSASS) - when a user logins into a workstation, whether it’s domain-joined or within a workgroup, WinLogon retrieves the user’s credentials to pass on to LSASS. An attacker can write their own DLL to hand over to WinLogon using special exports and intercept these plaintext credentials to write to a file of their choice. This was once proven by &lt;a href=&quot;https://twitter.com/0gtweet&quot;&gt;Grzegorz Tworek&lt;/a&gt; and later adopted by Red Canary’s Atomic Red Team framework, before eventually finding its way into a threat actor’s hands.&lt;/p&gt;

&lt;p&gt;Exchange was definitely a smart place to drop the malicious DLL, which also brings the question to how catastrophic NPPSPY could be when it comes to stealing credentials from other Active Directory services. Although I’m pretty sure they can do more than writing to files, I’ll be sticking to the topic and explaining later on the adversary’s implementation from the Huntress showcase.&lt;/p&gt;

&lt;p&gt;I also saw some detection methods Dray had used and thought I’d tap into my past experience within the SOC, then sprinkle in some other helpful hunting methods to the mix!&lt;/p&gt;

&lt;h2 id=&quot;detection-and-hunting-methods&quot;&gt;Detection and Hunting Methods&lt;/h2&gt;

&lt;figure class=&quot;align-center&quot; style=&quot;width: 549px&quot;&gt;
    &lt;img src=&quot;/assets/images/nppspy/professor.png&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;I may or may not have been (too) thorough, but the below would be technically most layers of detections and hunting methods to utilise if you ever handle a specimen that resembles or attempts to simulate the activity of NPPSPY. Of course, these detection methods may not be invincible as red teamers on Twitter very often demonstrate ways of evading and obfuscating their ways around them, but it would still catch your average script kiddie and lazy malware authors! Honestly, I’d say the Windows registry would be the easiest detection method, as there should be no reason it should change. If there’s not a ticket, then it is a crime! But without further ado, I will now take a deep dive into the detections! A fair amount of credit also goes to &lt;a href=&quot;https://twitter.com/snapattackHQ&quot;&gt;SnapAttackHQ&lt;/a&gt; for their &lt;a href=&quot;https://www.youtube.com/watch?v=XbdN8z0Rxic&quot;&gt;video&lt;/a&gt; also covering detection methods for NPPSPY, go check them out!&lt;/p&gt;

&lt;p&gt;MITRE Techniques: &lt;a href=&quot;https://attack.mitre.org/techniques/T1003/&quot;&gt;T1003 - OS Credential Dumping&lt;/a&gt; and &lt;a href=&quot;https://attack.mitre.org/techniques/T1556/002/&quot;&gt;T1556.002 - Modify Authentication Process: Password Filter DLL&lt;/a&gt;.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;PowerShell Script Block Logging&lt;/strong&gt; (event code &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;4104&lt;/code&gt;, practically my favourite one to hunt)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Process creation&lt;/strong&gt;: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;copy.exe&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;powershell&lt;/code&gt; or &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;reg.exe&lt;/code&gt;. These would be less likely to be written as detection rules, and more for hunting purposes to build a timeline of how the attacker carried out an attack to achieve their objectives.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;File creation&lt;/strong&gt; at &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;C:\Windows\System32\&lt;/code&gt; by an administrator account without any proof of legitimacy. There is a possibility that this can be easily slipped under the hood by impersonating the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SYSTEM&lt;/code&gt; account. The source file was a PE, but seeing from the ways malware authors have been &lt;strong&gt;wilding&lt;/strong&gt; with DLL names, the file extension can be trivial. Naming it wrongly can still make it stand out like a sore thumb and make a lot easier to detect the bad doing in your environment!&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;figure class=&quot; &quot;&gt;
  
  
&lt;/figure&gt;

&lt;figure class=&quot;align-center&quot; style=&quot;width: 400px&quot;&gt;
    &lt;img src=&quot;/assets/images/nppspy/spy.png&quot; /&gt;
        &lt;figcaption&gt;A real and true executable&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Registry modifications and creation&lt;/strong&gt; of the following (event IDs &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;12&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;13&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;4657&lt;/code&gt;):
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;HLKM\SYSTEM\CurrentControlSet\Control\NetworkProvider\Order&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;HLKM\SYSTEM\CurrentControlSet\Services\&amp;lt;Arbitrary Value&amp;gt;&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;HLKM\SYSTEM\CurrentControlSet\Services\&amp;lt;Arbitrary Value&amp;gt;\NetworkProvider&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;HLKM\SYSTEM\CurrentControlSet\Services\&amp;lt;Arbitrary Value&amp;gt;\NetworkProvider\Class&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;HLKM\SYSTEM\CurrentControlSet\Services\&amp;lt;Arbitrary Value&amp;gt;\NetworkProvider\Name&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;HLKM\SYSTEM\CurrentControlSet\Services\&amp;lt;Arbitrary Value&amp;gt;\NetworkProvider\ProviderPath&lt;/code&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;In terms of malware research and EDRs, I’d assume hooking the following APIs:
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CreateFile&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;WriteFile&lt;/code&gt; for file operations&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;RegOpenKey&lt;/code&gt; or &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;RegCreateKey&lt;/code&gt; followed by &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;RegSetValue&lt;/code&gt; or &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;RegQueryValue&lt;/code&gt;.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;File creation&lt;/strong&gt; from the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mpnotify.exe&lt;/code&gt; image (event ID &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;11&lt;/code&gt;) - within the next section, I will explain why!&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;lsassdll-static--dynamic-analysis&quot;&gt;‘lsass.dll’ Static &amp;amp; Dynamic Analysis&lt;/h2&gt;
&lt;p&gt;We will focus on two important functions: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NPGetCaps&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NPLogonNotify&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NPGetCaps&lt;/code&gt; returns values that are relevant to information on which services are supported on the network. This is mostly to resemble somewhat “legitimate” behaviour from a service DLL, and therefore loses its spotlight in the analysis!&lt;/p&gt;

&lt;figure class=&quot;align-center&quot; style=&quot;width: 311px&quot;&gt;
    &lt;img src=&quot;/assets/images/nppspy/npgetcaps.png&quot; alt=&quot;An absurdly benign and boring function presented by the NPGetCaps export!&quot; /&gt;
    &lt;figcaption&gt;An absurdly benign and boring function presented by the NPGetCaps export!&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;h3 id=&quot;nplogonnotify&quot;&gt;NPLogonNotify&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://learn.microsoft.com/en-us/windows/win32/api/npapi/nf-npapi-nplogonnotify&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NPLogonNotify&lt;/code&gt;&lt;/a&gt; calls &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SavePassword&lt;/code&gt;, therefore the meat of the malware is at &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0x180001000&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot; &quot;&gt;
  
    
      &lt;a href=&quot;/assets/images/nppspy/nplogonnotify.png&quot;&gt;
          &lt;img src=&quot;/assets/images/nppspy/nplogonnotify.png&quot; alt=&quot;&quot; /&gt;
      &lt;/a&gt;
    
  
  
&lt;/figure&gt;

&lt;p&gt;As seen in the below images, the adversary tried to obfuscate the malicious function with stack strings, which stored an encrypted file path that was later on decrypted for malicious DLL to write the stolen credentials to. While having the original NPPSpy code from GitHub made this obvious, this trick can still be useful in obfuscating the file in ways we do not expect and temporarily evading endpoint protection!&lt;/p&gt;

&lt;figure class=&quot;half &quot;&gt;
  
    
      &lt;a href=&quot;/assets/images/nppspy/stackstrings.png&quot; title=&quot;Greeted by a bunch of stack strings - very small compared to malware campaigns like Emotet!&quot;&gt;
          &lt;img src=&quot;/assets/images/nppspy/stackstrings.png&quot; alt=&quot;Greeted by a bunch of stack strings - very small compared to malware campaigns like Emotet!&quot; /&gt;
      &lt;/a&gt;
    
  
    
      &lt;a href=&quot;/assets/images/nppspy/decryption-routine.png&quot; title=&quot;Decryption loop at the end of the stack strings&quot;&gt;
          &lt;img src=&quot;/assets/images/nppspy/decryption-routine.png&quot; alt=&quot;Decryption loop at the end of the stack strings&quot; /&gt;
      &lt;/a&gt;
    
  
  
    &lt;figcaption&gt;Disassembly as shown by IDA. Tap them for a better view!
&lt;/figcaption&gt;
  
&lt;/figure&gt;

&lt;p&gt;When I initially loaded and decompiled the function within IDA, the psuedocode was heavily optimised so I needed to reconstruct the string at stack level. In all honesty, I spent the longest time of the analysis on this because I wasn’t aware that stack strings can appear differently than intended because of the way a decompiler translates from Assembly to psuedocode, but it was still a great learning experience and a powerful reminder that no tool is perfect and will almost always require intervention from its user.&lt;/p&gt;

&lt;figure class=&quot; &quot;&gt;
  
    
      &lt;a href=&quot;/assets/images/nppspy/stackstrings-before-vs-after.png&quot; title=&quot;Before vs after cleaning up the psuedocode with labelling&quot;&gt;
          &lt;img src=&quot;/assets/images/nppspy/stackstrings-before-vs-after.png&quot; alt=&quot;&quot; /&gt;
      &lt;/a&gt;
    
  
  
&lt;/figure&gt;

&lt;p&gt;After reconstructing the stack string and using Python to replicate the decryption routine, it was revealed that the stack string eventually resolved to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;C:\\ProgramData\\Package Cache\\Windows10.0-KB5009543-x64.msu&lt;/code&gt;. This demonstrates that the attacker had tried to masquerade the dropped file as a standalone Windows Update file, which can be very tricky for a defender to spot!&lt;/p&gt;

&lt;p&gt;With this theory in mind, I performed some dynamic analysis to prove the suspected behaviour.&lt;/p&gt;

&lt;figure class=&quot;align-center&quot; style=&quot;width: 856px&quot;&gt;
    &lt;img src=&quot;/assets/images/nppspy/oneliner.png&quot; /&gt;
    &lt;figcaption&gt;PowerShell commands written across as a messy one-liner to replicate the attack scenario&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;figure class=&quot;align-center&quot; style=&quot;width: 887px&quot;&gt;
    &lt;img src=&quot;/assets/images/nppspy/dropped-credentials.png&quot; /&gt;
    &lt;figcaption&gt;The world's strongest password revealed and written over to `Windows10.0-KB5009543-x64.msu&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;Since the file was dropped on disk, I believed it would be impossible to not be able to detect it through Sysmon, so I decided test some custom rules. Adding the below detection rule to the Sysmon config file from &lt;a href=&quot;https://github.com/SwiftOnSecurity/sysmon-config/&quot;&gt;SwiftOnSecurity&lt;/a&gt;, it was revealed that &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mpconfig.exe&lt;/code&gt; would be responsible for the file creation activity:&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;TargetFilename name=&quot;OSCredentialDumping&quot; condition=&quot;end with&quot;&amp;gt;Windows10.0-KB5009543-x64.msu&amp;lt;/TargetFilename&amp;gt; &amp;lt;!--File created from lsass.dll/NPPSpy--&amp;gt;&lt;/code&gt;&lt;/p&gt;

&lt;figure class=&quot;align-center&quot; style=&quot;width: 900px&quot;&gt;
    &lt;img src=&quot;/assets/images/nppspy/sysmon.png&quot; /&gt;
    &lt;figcaption&gt;mpnotify.exe shown to create files from the detection rules&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mpnotify.exe&lt;/code&gt; has not been known to create or write any files as shown by this &lt;a href=&quot;https://strontic.github.io/xcyclopedia/library/mpnotify.exe-8F9739E266623499391CBAC652A01036.html&quot;&gt;post&lt;/a&gt;. I suspect that attackers may find more use for it than just theft of passwords though. For example, they can force an implant to run on another thread or simply open a HTTP connection to send credentials back to a C2 server - the possibilities are endless! Again, this requires administrator privileges and will be quite noisy.&lt;/p&gt;

&lt;h2 id=&quot;yara-time&quot;&gt;YARA Time&lt;/h2&gt;
&lt;p&gt;After performing the static and dynamic analysis on the DLL, I thought it was about time I demonstrated how I would use &lt;a href=&quot;https://twitter.com/cyb3rops&quot;&gt;Florian Roth&lt;/a&gt;’s excellent tool, YARA!&lt;/p&gt;

&lt;p&gt;In my eCTHPv2 review post, I talked about how YARA and other forms of detection rules can only be as great as the people that wrote them. For anyone else who’s learning, allow me to walk you through a few steps I’d go!&lt;/p&gt;

&lt;p&gt;When creating YARA rules, you’d target the most critical malicious functions (TTPs), followed by hardcoded strings that appear to be written by a human. If possible, you would also conduct a comparative analysis to search for reused code, which the &lt;a href=&quot;https://www.zynamics.com/bindiff.html&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BinDiff&lt;/code&gt;&lt;/a&gt; tool can be very helpful for. In order to achieve a goal, an adversary tends to exhibit certain behaviours regardless of their tools, though some differ a lot more than others when being heavily OPSEC-focused. However, by targeting the TTPs, you’re essentially ruling based on the behaviour of a malware specimen, and causing a threat actor to put more effort into obfuscating their activity or entirely switch tools altogether. It then becomes a cyclic arms race - with the threat actor rewriting or hiding their tools and you revising and evolving your detection rules! Although it may not be as easy as it sounds, once you get used to analysing malware across different campaigns, you would then begin to notice certain patterns, profile threat actors and even spot when they introduce some new quirks and ‘updates’ into their bad doing!&lt;/p&gt;

&lt;p&gt;In the case of malware research, this meant retrieving opcodes for certain operations such as encryption algorithms, file &amp;amp; registry operations - basically anything that would be require a lot of effort to obfuscate. The main things I focused on were the stack strings as well as the common exports and algorithms and across both samples, plus any extras like decrypted strings to make them adapted for certain hunts whether on VirusTotal or through Volatility’s in-memory &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;yarascan&lt;/code&gt; module. There may be a chance you’d capture payloads and useful strings while they are decrypted in memory! The below YARA rule draft reflects the observations I made on both the original and custom NPPSPY DLLs:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import &quot;pe&quot;

rule nppspy_or_variants
{
    meta:
        name = &quot;NPPSpy and Variants&quot;
        description = &quot;Malware Hunt - The Curious Case of MPNotify &amp;amp; NPPSPY&quot;
        techniques = &quot;T1003, T1556.002&quot;
        weaponisation = &quot;Masquarades as lsass.dll, and then extracts the credentials from WinLogon by getting sideloaded within MpNotify to dump into a file.&quot;
        reference = &quot;https://www.huntress.com/blog/cleartext-shenanigans-gifting-user-passwords-to-adversaries-with-nppspy&quot;
        report = &quot;https://www.malwareguy.tech/Hunts/nppspy.html&quot;
        author = &quot;Malware Guy&quot;
        version = &quot;1.1&quot;
        hash1 = &quot;e30f8596f1beda8254cbe1ac7a75839f5fe6c332f45ebabff88aadbce3938a19&quot;
        hash2 = &quot;b283415c9df06f0e53b7d452d3e5c840c5bd7a6ce734a30bae4a869a57974a0e&quot;
    
    strings:
        $s1 = &quot;C:\\NPPSpy.txt&quot; wide
        $s2 = &quot;NPPSPY.dll&quot; fullword ascii
        $s3 = &quot;C:\\ProgramData\\Package Cache\\Windows10.0-KB5009543-x64.msu&quot; // Added for redundancy
        $opcodes1 = { C6 84 24 ?? ?? 00 00 ?? } // Stack Strings
        $opcodes2 = { C6 44 24 ?? ?? } // Stack Strings
        $opcodes3 = { 48 63 44 24 40 48 83 F8 ?? } // Set up the path to decrypt - beginning
        $opcodes4 = { 48 63 44 24 40 0F BE 44 04 78 89 44 24 50 48 63 4C 24 40 33 D2 48 8B C1 B9 20 00 00 00 48 F7 F1 48 8B C2 0F BE 44 04 58 8B 4C 24 50 33 C8 8B C1 48 63 4C 24 40 88 84 0C 58 01 00 00 E9 46 FC FF FF } // String Decryption Routine
        $opcodes5 = { 8B 44 24 40 FF C0 89 44 24 40 48 63 44 24 40 } // Increment index and repeat loop

        condition:
            ((uint16(0) == 0x5A4D) and (uint32(uint32(0x3C)) == 0x00004550)) and (pe.exports(&quot;NpGetCaps&quot;) and pe.exports(&quot;NpLogonNotify&quot;)) and ((pe.imports(&quot;kernel32.dll&quot;, &quot;CreateFileA&quot;) or pe.imports(&quot;kernel32.dll&quot;, &quot;CreateFileW&quot;)) and (pe.imports(&quot;kernel32.dll&quot;, &quot;WriteFile&quot;) and pe.imports(&quot;kernel32.dll&quot;, &quot;SetFilePointer&quot;))) and (((2 of ($s*)) and pe.pdb_path == &quot;C:\\Users\\GrzegorzTworek\\source\\repos\\NPPSpy\\x64\\Release\\NPPSPY.pdb&quot;) or (2 of ($opcodes*)))
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;After a great amount of trial and error, the YARA rules eventually alerted on both specimen!&lt;/p&gt;

&lt;figure class=&quot;align-center&quot; style=&quot;width: 860px&quot;&gt;
    &lt;img src=&quot;/assets/images/nppspy/yaratest.png&quot; /&gt;
&lt;/figure&gt;

&lt;figure class=&quot;align-center&quot; style=&quot;width: 596px&quot;&gt;
    &lt;img src=&quot;/assets/images/nppspy/stonks.jpeg&quot; /&gt;
&lt;/figure&gt;

&lt;h2 id=&quot;mitigations&quot;&gt;Mitigations&lt;/h2&gt;
&lt;p&gt;EDIT: On Twitter, Grzegorz Tworek himself offered a mitigation method which prevents the attack from being successful:&lt;/p&gt;
&lt;blockquote class=&quot;twitter-tweet&quot;&gt;&lt;p lang=&quot;en&quot; dir=&quot;ltr&quot;&gt;If you are responsible for Win11 security baseline, please use the new (I mean fixed after 20+ years) configuration option &amp;quot;Enable MPR notifications&amp;quot; under Windows Components\Windows Logon Options.&lt;br /&gt;Defaults allow to read cleartext credentials from Winlogon with a simple DLL. &lt;a href=&quot;https://t.co/pUBWQCNkeI&quot;&gt;pic.twitter.com/pUBWQCNkeI&lt;/a&gt;&lt;/p&gt;&amp;mdash; Grzegorz Tworek (@0gtweet) &lt;a href=&quot;https://twitter.com/0gtweet/status/1610914693912166400?ref_src=twsrc%5Etfw&quot;&gt;January 5, 2023&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async=&quot;&quot; src=&quot;https://platform.twitter.com/widgets.js&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;

&lt;h2 id=&quot;final-thoughts&quot;&gt;Final Thoughts&lt;/h2&gt;
&lt;p&gt;Thank you for reading my post! I’ve learned quite a bit from hunting this specimen, and as usual, only ever plan on doing even more. Because of a few select individuals within the Infosec community, I am now slightly more knowledgeable about how Windows environments (dangerously) handle authentication, and have my own input to give you guys within the community something to read.&lt;/p&gt;

&lt;p&gt;I consider the YARA rule I’ve written in this post to be a draft, and there may be another version of it depending on if criminal hackers adopted this technique a lot more (very unlikely, hopefully) and I looked at this malware family again. Either way, having stronger and layered detection rules increases your confidence that you (or your AI) will have a better chance of catching certain malware once it makes its way into your environment! I also had a Sigma hunting and IOC rule related to the malicious activity published on SOC Prime, if you would like to give it a test run, check it out &lt;a href=&quot;https://tdm.socprime.com/tdm/info/n8oCdFvnALY7/?p=1&quot;&gt;here&lt;/a&gt;. You will need an account to access it!&lt;/p&gt;

&lt;p&gt;If you would like to learn a few helpful malware research techniques and have some experience with IDA already, I’d definitely recommend the &lt;a href=&quot;https://courses.zero2auto.com&quot;&gt;Zero2Automated&lt;/a&gt; course! If you also happen to have any feedback about my post or have suggestions on what I could work on, you’re more than welcome to reach out to me on any of my handles! I also stream, so if you’re down for a chat whenever I’m live then just drop by anytime.&lt;/p&gt;

&lt;figure class=&quot; &quot;&gt;
  
    
      &lt;a href=&quot;/assets/images/nppspy/vegito.gif&quot;&gt;
          &lt;img src=&quot;/assets/images/nppspy/vegito.gif&quot; alt=&quot;&quot; /&gt;
      &lt;/a&gt;
    
  
  
&lt;/figure&gt;

&lt;h2 id=&quot;references&quot;&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;lsass.dll:&lt;/strong&gt;
SHA256: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;E30F8596F1BEDA8254CBE1AC7A75839F5FE6C332F45EBABFF88AADBCE3938A19&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.virustotal.com/gui/file/e30f8596f1beda8254cbe1ac7a75839f5fe6c332f45ebabff88aadbce3938a19/&quot;&gt;https://www.virustotal.com/gui/file/e30f8596f1beda8254cbe1ac7a75839f5fe6c332f45ebabff88aadbce3938a19/&lt;/a&gt;
&lt;a href=&quot;https://analyze.intezer.com/analyses/ea11eeb9-d345-46e3-a1cb-2ce47f933ee0&quot;&gt;https://analyze.intezer.com/analyses/ea11eeb9-d345-46e3-a1cb-2ce47f933ee0&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Atomic Red Team:&lt;/strong&gt;
&lt;a href=&quot;https://github.com/redcanaryco/atomic-red-team/blob/master/atomics/T1003/T1003.md#atomic-test-2---credential-dumping-with-nppspy&quot;&gt;https://github.com/redcanaryco/atomic-red-team/blob/master/atomics/T1003/T1003.md#atomic-test-2—credential-dumping-with-nppspy&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Original PoC:&lt;/strong&gt;
SHA256: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;B283415C9DF06F0E53B7D452D3E5C840C5BD7A6CE734A30BAE4A869A57974A0E&lt;/code&gt;
&lt;a href=&quot;https://github.com/gtworek/PSBits/blob/master/PasswordStealing/NPPSpy/NPPSPY.dll&quot;&gt;https://github.com/gtworek/PSBits/blob/master/PasswordStealing/NPPSpy/NPPSPY.dll&lt;/a&gt;
&lt;a href=&quot;https://analyze.intezer.com/analyses/7d8a7434-258e-4e87-a1c7-e832485a51b4&quot;&gt;https://analyze.intezer.com/analyses/7d8a7434-258e-4e87-a1c7-e832485a51b4&lt;/a&gt;&lt;/p&gt;</content><author><name>Malware Guy</name></author><category term="[&quot;Hunts&quot;]" /><category term="NPPSpy" /><category term="IDA" /><category term="CAPA Explorer" /><category term="Sysmon" /><category term="Sigma" /><category term="YARA" /><summary type="html">Today’s hunt was inspired from this awesome blog by Dray Agha! Also a special thanks to Robsware for taking the time out his day to proofread this post! Bug, bother, nudge - show those two horrendously cool blokes all the love you can muster and ask them all about their expert knowledge on lsass.dll!</summary></entry><entry><title type="html">Patching</title><link href="http://localhost:4000/RE-notes/patching.html" rel="alternate" type="text/html" title="Patching" /><published>2022-12-14T00:00:00+00:00</published><updated>2022-12-14T00:00:00+00:00</updated><id>http://localhost:4000/RE-notes/Patching</id><content type="html" xml:base="http://localhost:4000/RE-notes/patching.html">&lt;p&gt;I wrote this post as I thought it would be fun to explore some reverse engineering techniques — in (almost) simplified terms! Typically, patching can be used to bypass detection methods employed by strung malware authors who want to add on a bit of challenge to slow down and increase the difficulty of analysis.&lt;/p&gt;

&lt;p&gt;Even with something as simple as &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IsDebuggerPresent&lt;/code&gt; or &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Sleep&lt;/code&gt; or complex techniques such as the use of Structured Exception Handlers, you can apply these methods to defeat the defences employed by malware which would otherwise lead to undesirable results. When it also comes to slightly more complicated detection methods (use of the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;rdtsc&lt;/code&gt; instruction for time-based detection, Structured Exception Handling or hardware breakpoint detection), it is left to the analyst’s imagination as well as their knowledge and experience to defeat those mechanisms.&lt;/p&gt;

&lt;p&gt;Using a plugin like ScyllaHide within x64dbg can be a massive shortcut — it may prevent the debugger from being detected by the malware specimen, but that would not stop it from discovering specific things like parent processes, monitoring and analysis tools running or installed on systems, or utilising certain sequences of Assembly instructions that would reveal that it is being run inside a virtual machine. However, combining or applying either of these where you can would help you adapt to pretty much anything malware throws at you, and you become a much more effective reverse engineer. Repeat after me, patching is applying duct tape to &lt;del&gt;all your problems&lt;/del&gt; logic!&lt;/p&gt;

&lt;figure class=&quot;&quot;&gt;
  &lt;img src=&quot;/assets/images/patching/20221213193543.png&quot; alt=&quot;&quot; /&gt;&lt;/figure&gt;

&lt;p&gt;A short disclaimer though, this post is intended to cover some basic techniques that will face off &lt;em&gt;basic&lt;/em&gt; evasion methods. Unfortunately I will not cover topics such as devirtualising Assembly instructions as I am not yet on that level, but I possibly could in a future post.&lt;/p&gt;

&lt;p&gt;That said, patching is pretty much a core task in any reverse engineer’s toolkit regardless of skill level, so allow me to take you through a few!&lt;/p&gt;

&lt;h2 id=&quot;bypass-methods&quot;&gt;Bypass Methods&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;If you would like to follow along, feel free to download the IcedID sample within the References section of this post! You are invited to change the &lt;em&gt;DLL can move&lt;/em&gt; property through CFF Explorer within &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DllCharacteristics&lt;/code&gt;!&lt;/strong&gt;&lt;/p&gt;

&lt;figure class=&quot;&quot;&gt;
  &lt;img src=&quot;/assets/images/patching/20221213194039.png&quot; alt=&quot;&quot; /&gt;&lt;/figure&gt;

&lt;h3 id=&quot;reversing-the-logic&quot;&gt;Reversing the logic&lt;/h3&gt;
&lt;p&gt;Just like human beings, malware and software programs as a whole operate on logic, just without the feelings holding them back! To put it simply, programs are series of instructions that have a control flow based on the conditions of their environment (user input, running procesesses, OS-determined variables etc.) and change their behaviours to adapt based on those outcomes. Some may be within your control while others are not, but inside a debugger and disassembler, the world is yours to rule.&lt;/p&gt;

&lt;figure class=&quot;&quot;&gt;
  &lt;img src=&quot;/assets/images/patching/20221127012139.png&quot; alt=&quot;&quot; /&gt;&lt;/figure&gt;

&lt;p&gt;In the below psuedocode, let’s imagine the malware specimen had called an anti-debugger detection method, and the variable of the result was stored and checked to determine the next behaviours it would exhibit:&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// perform some code based on the successful if statement&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// do something else&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Within Assembly, this code would be disassembled as the following:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-asm&quot;&gt;cmp eax, 1
jz ResultWasOne
xor eax, eax ; XORing out eax would store 0 in the return value, and also indicate the conditional jump wasn't taken
ret

ResultWasOne:
xchg eax, eax ; perform some code based on the successful if statement
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Changing &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;jz&lt;/code&gt; to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;jnz&lt;/code&gt; cause the complete opposite effect to happen — the function ends up returning &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0&lt;/code&gt; (essentially performing the XOR operation on &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;eax&lt;/code&gt; within Assembly) and moving the flow of the program to the caller of the function.&lt;/p&gt;

&lt;p&gt;Within your tools, you can use graph views to determine where the jump actually goes and what happens based on this decision. To make your life slightly easier, do the following to show instruction addresses while in Graph View in IDA - &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Graph view &amp;gt; Options &amp;gt; General &amp;gt; Disassembly &amp;gt; Line prefixes (graph)&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The colours of arrows can also be generally helpful for understanding the control flow of a program:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Red signifies an unsuccessful result&lt;/li&gt;
  &lt;li&gt;Green signifies a successful result&lt;/li&gt;
  &lt;li&gt;Code blocks that branch out across numerous blue arrows often indicate a jump table is in use — this is particularly common in keyloggers and encryption algorithms, possibly even more when malware authors had attempted to obfuscate their flow!&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Inside the IcedID specimen, I will be covering the two anti-debugging techniques:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IsDebuggerPresent&lt;/code&gt;, which actually checks the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PEB.BeingDebugged&lt;/code&gt; member within the PEB behind the scenes, and if it is set to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1&lt;/code&gt;, the return value is also &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1&lt;/code&gt; (&lt;a href=&quot;https://learn.microsoft.com/en-us/windows/win32/api/winternl/ns-winternl-peb&quot;&gt;reference&lt;/a&gt;).&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;OutputDebugStringW&lt;/code&gt; method relies on the fact that if the process is being debugged, then the return value in &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;eax&lt;/code&gt; would be a valid address inside the virtual address of the process, otherwise will be &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0&lt;/code&gt; or &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1&lt;/code&gt; as mentioned. Since &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1&lt;/code&gt; are not valid virtual addresses, if the program attempts to access those addresses, a memory access violation exception (exception code &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0xC0000005&lt;/code&gt;) will occur, the execution will then be transferred to an exception handler and the program will be able to detect that the calling process is not debugged. If no exception occurs, then it means that the calling process is running under a debugger.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Notice how the opcodes (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Options &amp;gt; General &amp;gt; Number of opcodes (graph)&lt;/code&gt; — set to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;8&lt;/code&gt;) for each conditional jump inside each anti-debug technique changes within the screenshots:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Before:&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;&quot;&gt;
  &lt;img src=&quot;/assets/images/patching/20221213103852.png&quot; alt=&quot;&quot; /&gt;&lt;/figure&gt;

&lt;p&gt;&lt;strong&gt;After:&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;&quot;&gt;
  &lt;img src=&quot;/assets/images/patching/20221213104545.png&quot; alt=&quot;&quot; /&gt;&lt;/figure&gt;

&lt;p&gt;Reversing the logic of the instructions will cause the program to behave in the exact opposite way it was originally written. To keep track of your patched instructions, you can view them in IDA:&lt;/p&gt;

&lt;figure class=&quot;&quot;&gt;
  &lt;img src=&quot;/assets/images/patching/20221213104609.png&quot; alt=&quot;&quot; /&gt;&lt;/figure&gt;

&lt;h3 id=&quot;fill-with-nops&quot;&gt;Fill with NOPs&lt;/h3&gt;
&lt;p&gt;The &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;nop&lt;/code&gt; instruction has many uses, and it is so versatile that it is being used by malware authors and reverse engineers alike! In exploit dev, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;nop&lt;/code&gt; sleds are normally used to allow malware to unpack their shellcode into unoccupied regions of memory within their target.&lt;/p&gt;

&lt;figure class=&quot;&quot;&gt;
  &lt;img src=&quot;/assets/images/patching/nop-baby.png&quot; alt=&quot;&quot; /&gt;&lt;/figure&gt;

&lt;p&gt;In malware development, its logic can also be used in a series of instructions to waste analysis time with calculations that land back to square one, such an example being &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;push eax&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;xchg eax, eax&lt;/code&gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;add eax, 1&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pop eax&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;In the case of reverse engineering, filling an area of a program with a series of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;nop&lt;/code&gt; instructions is essentially replacing their opcodes with &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;90&lt;/code&gt; and causing it to do absolutely &lt;em&gt;nothing&lt;/em&gt; in that short region for the reward of &lt;em&gt;everything&lt;/em&gt; your specimen has to offer!&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Before:&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;&quot;&gt;
  &lt;img src=&quot;/assets/images/patching/20221213195522.png&quot; alt=&quot;&quot; /&gt;&lt;/figure&gt;

&lt;p&gt;&lt;strong&gt;After&lt;/strong&gt;:&lt;/p&gt;
&lt;figure class=&quot;&quot;&gt;
  &lt;img src=&quot;/assets/images/patching/20221214100618.png&quot; alt=&quot;&quot; /&gt;&lt;/figure&gt;

&lt;figure class=&quot;&quot;&gt;
  &lt;img src=&quot;/assets/images/patching/nope.png&quot; alt=&quot;&quot; /&gt;&lt;/figure&gt;

&lt;p&gt;Notice how x64dbg fills the space occupied by the previous anti-analysis opcodes with that many bytes! Which takes us to the following section…&lt;/p&gt;

&lt;h3 id=&quot;opcode-patching&quot;&gt;Opcode Patching&lt;/h3&gt;
&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;jz&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;jnz&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;jg&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;jl&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;These have one thing in common; apart from starting with a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;j&lt;/code&gt;, they are all assembly instructions for which their purpose in comparisons are facilitate conditional jumps, and they all have opcodes!&lt;/p&gt;

&lt;p&gt;Here is an example of a conditional jump:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;74 07&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;74&lt;/code&gt; stands for &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;jz&lt;/code&gt; or &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;je&lt;/code&gt;, and the argument causes the program to make a jump &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;07&lt;/code&gt; bytes forward (moving the instruction pointer that many bytes away) if the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ZF&lt;/code&gt; flag is not set to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1&lt;/code&gt;. Re-assembling the opcodes from &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;74 07&lt;/code&gt; to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;74 00&lt;/code&gt; would essentially be a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;nop&lt;/code&gt;! To make better sense of it, here is a visualisation of what a patched jump would look like:&lt;/p&gt;

&lt;figure class=&quot;&quot;&gt;
  &lt;img src=&quot;/assets/images/patching/jump.gif&quot; alt=&quot;&quot; /&gt;&lt;/figure&gt;

&lt;p&gt;To perform this within IDA, click &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Edit &amp;gt; Patch program &amp;gt; Change byte&lt;/code&gt; and change &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;07&lt;/code&gt; to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;00&lt;/code&gt; like shown in the screenshot:&lt;/p&gt;

&lt;figure class=&quot;&quot;&gt;
  &lt;img src=&quot;/assets/images/patching/20221213194500.png&quot; alt=&quot;&quot; /&gt;&lt;/figure&gt;

&lt;p&gt;Notice the difference on the arrows as well as the jump destination!&lt;/p&gt;

&lt;figure class=&quot;&quot;&gt;
  &lt;img src=&quot;/assets/images/patching/20221213194615.png&quot; alt=&quot;&quot; /&gt;&lt;/figure&gt;

&lt;p&gt;This can also apply for unconditional jumps (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;jmp&lt;/code&gt;), but you must know where you’re landing to make sure you don’t break the program! On another note, being aware of opcodes can also be important if you want to write YARA rules for code reuse across malware within a campaign. Although you do not need to memorise them, here is a &lt;a href=&quot;http://ref.x86asm.net/coder32.html&quot;&gt;reference&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&quot;direct-patching&quot;&gt;Direct Patching&lt;/h3&gt;
&lt;p&gt;This method would be slightly more challenging, seeing as you would require some knowledge around the PE format (long live &lt;a href=&quot;https://learn.microsoft.com/en-us/windows/win32/debug/pe-format&quot;&gt;MSDN&lt;/a&gt;!)&lt;/p&gt;

&lt;p&gt;To be successful with this method, you use the following equation to calculate the offset and directly edit a binary inside a hex editor:&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Offset = VirtualAddress - (ImageBase + RelativeVirtualAddressOfSection) + PointerToRawData&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;To start, you’d have to retrieve the virtual address from IDA or x64dbg — in this case, we will use &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0x40863E&lt;/code&gt;, as this was one of the virtual addresses for the argument for the conditional jump spotted within the IcedID specimen.&lt;/p&gt;

&lt;p&gt;Next, you would need the relative virtual address of the section (typically calculated through &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;RelativeVirtualAddress = VirtualAddress - ImageBase&lt;/code&gt;) as well as the value stored within  &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PointerToRawData&lt;/code&gt;. Detect It Easy simplifies finding this is as much as possible, although you can also have a look at the structure from &lt;a href=&quot;https://learn.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-image_section_header&quot;&gt;MSDN&lt;/a&gt;.&lt;/p&gt;

&lt;figure class=&quot;&quot;&gt;
  &lt;img src=&quot;/assets/images/patching/20221213190119.png&quot; alt=&quot;&quot; /&gt;&lt;/figure&gt;

&lt;p&gt;While we’re at it, we can also obtain the value of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ImageBase&lt;/code&gt;, which is usually &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0x400000&lt;/code&gt; by default for 32-bit EXEs and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0x10000000&lt;/code&gt; for DLLs (you can find out more &lt;a href=&quot;https://learn.microsoft.com/en-us/cpp/build/reference/base-base-address&quot;&gt;here&lt;/a&gt;).&lt;/p&gt;

&lt;figure class=&quot;&quot;&gt;
  &lt;img src=&quot;/assets/images/patching/20221213192900.png&quot; alt=&quot;&quot; /&gt;&lt;/figure&gt;

&lt;p&gt;Finally, we are left with the final equation: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Offset = 0x40863E - (0x1000 + 0x400000) + 0x400&lt;/code&gt;. To get the offset, we would perform the following inside a hex calculator, which can either be your regular RE tools or even the default Windows calculator:&lt;/p&gt;

&lt;figure class=&quot;&quot;&gt;
  &lt;img src=&quot;/assets/images/patching/20221213190221.png&quot; alt=&quot;&quot; /&gt;&lt;/figure&gt;

&lt;p&gt;At offset &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0x7A3E&lt;/code&gt; within HxD, we can see the exact instructions we were looking for!&lt;/p&gt;

&lt;figure class=&quot;&quot;&gt;
  &lt;img src=&quot;/assets/images/patching/20221213190426.png&quot; alt=&quot;&quot; /&gt;&lt;/figure&gt;

&lt;p&gt;You can also use tools such as CFF Explorer, PE-bear and even Python’s &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pefile&lt;/code&gt; module to patch binaries while they aren’t loaded into memory. Several of them even contain built-in offset calculators and hex editors!&lt;/p&gt;

&lt;figure class=&quot;&quot;&gt;
  &lt;img src=&quot;/assets/images/patching/20221213184810.png&quot; alt=&quot;&quot; /&gt;&lt;/figure&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;Whether you use a disassembler, debugger, or even a simple hex editor, patching can help you circumvent anti-analysis detections used by malware. In the case of dnSpy, it can even be as simple as right-clicking an area of the program you don’t like, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Edit IL Instructions&lt;/code&gt;, making the changes then saving the module to patch the binary (see an example &lt;a href=&quot;https://www.malwareguy.tech/Hunts/redline-stealer.html#anti-debugging-dnspy&quot;&gt;here&lt;/a&gt;). This is even super effective against malware that attempts to verify checksums against its own executable sections to make double sure that it isn’t being analysed. If you run into trouble, you can always look at the mitigations recommended by &lt;a href=&quot;https://unprotect.it/&quot;&gt;Unprotect.it&lt;/a&gt; and CheckPoint’s &lt;a href=&quot;https://anti-debug.checkpoint.com/&quot;&gt;Anti-Debug&lt;/a&gt;. You can also have a look at several anti-analysis techniques from an adversary’s point of view inside the &lt;a href=&quot;https://github.com/LordNoteworthy/al-khaser&quot;&gt;Al-Khaser&lt;/a&gt; GitHub repo.&lt;/p&gt;

&lt;p&gt;Whenever you are doing this via a debugger, make sure you also &lt;strong&gt;save&lt;/strong&gt; the file, as the patches done will only apply for the one time the PE is loaded into memory! Inside x64dbg: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;File &amp;gt; Patch file&lt;/code&gt;:&lt;/p&gt;

&lt;figure class=&quot;&quot;&gt;
  &lt;img src=&quot;/assets/images/patching/20221213200705.png&quot; alt=&quot;&quot; /&gt;&lt;/figure&gt;

&lt;p&gt;If you found this post useful, please share it with other beginner reverse engineers who are just starting out, and feel free to reach out to me on any of my social media handles if you have any questions or comments on the post!&lt;/p&gt;

&lt;p&gt;Mini-challenge: Try to change the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DllCharacteristics&lt;/code&gt; field of the optional header without relying on CFF Explorer! Check &lt;a href=&quot;https://learn.microsoft.com/en-us/windows/win32/debug/pe-format#dll-characteristics&quot;&gt;here&lt;/a&gt; for clues.&lt;/p&gt;

&lt;h2 id=&quot;references&quot;&gt;References&lt;/h2&gt;
&lt;p&gt;SHA256: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;76cd290b236b11bd18d81e75e41682208e4c0a5701ce7834a9e289ea9e06eb7e&lt;/code&gt;
&lt;a href=&quot;https://bazaar.abuse.ch/sample/76cd290b236b11bd18d81e75e41682208e4c0a5701ce7834a9e289ea9e06eb7e/&quot;&gt;https://bazaar.abuse.ch/sample/76cd290b236b11bd18d81e75e41682208e4c0a5701ce7834a9e289ea9e06eb7e/&lt;/a&gt;&lt;/p&gt;</content><author><name>Malware Guy</name></author><category term="RE Notes" /><category term="HxD" /><category term="IDA" /><category term="x64dbg" /><category term="Detect It Easy" /><category term="CFF Explorer" /><summary type="html">I wrote this post as I thought it would be fun to explore some reverse engineering techniques — in (almost) simplified terms! Typically, patching can be used to bypass detection methods employed by strung malware authors who want to add on a bit of challenge to slow down and increase the difficulty of analysis.</summary></entry><entry><title type="html">My eCTHPv2 Experiences</title><link href="http://localhost:4000/Course-Reviews/eCTHPv2.html" rel="alternate" type="text/html" title="My eCTHPv2 Experiences" /><published>2022-10-29T00:00:00+01:00</published><updated>2022-10-29T00:00:00+01:00</updated><id>http://localhost:4000/Course-Reviews/eCTHPv2-Review</id><content type="html" xml:base="http://localhost:4000/Course-Reviews/eCTHPv2.html">&lt;p&gt;I taken eCTHPv2 back in April, and eventually decided I wanted to write my personal thoughts and overall experience around the course!&lt;/p&gt;

&lt;figure class=&quot;&quot;&gt;
  &lt;img src=&quot;/assets/images/ecthpv2/ecthpv2_logo.png&quot; alt=&quot;&quot; /&gt;&lt;figcaption&gt;
      

    &lt;/figcaption&gt;&lt;/figure&gt;

&lt;p&gt;&lt;a href=&quot;https://elearnsecurity.com/product/ecthpv2-certification/&quot;&gt;https://elearnsecurity.com/product/ecthpv2-certification/&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;background--endeavours&quot;&gt;Background &amp;amp; Endeavours&lt;/h2&gt;
&lt;p&gt;I initially started brushing through eCTHPv2 out of pure curiosity while I was nearing the end of my level 4 apprenticeship, then fully committed to it after I passed eCPPTv2. Around that time, I already had two years of SOC experience. I knew how to use a SIEM and had a strong idea what stood out as a swollen thumb.&lt;/p&gt;

&lt;p&gt;This course places you in the shoes of a threat hunter, setting out with or without data and the assumption (and near paranoia) that you had already been breached. While that could sound a little dramatic, all you had to do is then gain the evidence to support the theory that the organisation you’re ferociously hunting through has a very stealthy threat actor on the loose!&lt;/p&gt;

&lt;p&gt;I decided to take the course for this exact reason - to build my hunting capabilities, and be able to act at a time an embedded or sophisticated cyber attack was missed by the SOC and existing security infrastructure. Not all attacks involved deploying malware or running exploits as threat actors and red teamers tended to mimic legitimate admin activity inside an environment to evade detection, so gaining the knowledge and skills from eCTHPv2 was crucial to my growth!&lt;/p&gt;

&lt;figure class=&quot;&quot;&gt;
  &lt;img src=&quot;/assets/images/ecthpv2/lion.png&quot; alt=&quot;&quot; /&gt;&lt;figcaption&gt;
      

    &lt;/figcaption&gt;&lt;/figure&gt;

&lt;p&gt;In my case, it was my first exposure to the Windows API, featuring code injection techniques (which helped me to identify process hollowing, see my &lt;a href=&quot;https://www.malwareguy.tech/Hunts/redline-stealer.html&quot;&gt;hunt&lt;/a&gt; on Redline Stealer!) and other evasion methods used by threat actors. The course presented tools such as Captain, Sysmon and SilkETW which were supposed to nearly emulate the functionality of simplified EDRs and other detection tools and grant an understanding of what to search for when triaging a suspicious endpoint. What I also learned from this section was, the same defensive tools use code injections and hooking techniques themselves!&lt;/p&gt;

&lt;p&gt;It also allowed me to work more intimately with the MITRE ATT&amp;amp;CK framework. ELK Stack and Splunk were both core topics within eCTHPv2, and I remembered doing at least 15 labs based on them! Because I already understood how to use a SIEM (particularly Splunk), they were able to easily fit on my hand like a glove, and it was only a matter of understanding TTPs then using the MITRE ATT&amp;amp;CK framework as a guidance and adapt whenever I ran into trouble. Because of this, it also made it much easier to understand red teams a lot better especially in adversary simulation scenarios where both sides needed to speak a global language.&lt;/p&gt;

&lt;p&gt;Some of the modules additionally expected you to perform network traffic analysis on PCAPs using Wireshark and Network Miner. WIthin corporate environments, every device within the network generates a high amount of traffic, so security teams generally preferred using NetFlows or logs from IDS and AVs/EDRs to investigate suspicious network activity as they lacked a budget for storing any long-term PCAP data. After gaining exposure through investigating PCAPs in the exercises, it bridged the gap in my knowledge and I had a better idea of how to carve out forensic data from network captures, which can be super helpful for real-life hunting or incident response engagements where an endpoint or several of them exhibit anomalous activity.&lt;/p&gt;

&lt;p&gt;One of the other key highlights was learning memory forensics with Volatility and Mandiant Redline. Around the time I was taking the course, I found memory forensics with Volatility to be slightly challenging in some of the labs as I did not know how to read Assembly language. However, with some labs from TryHackMe and &lt;a href=&quot;https://github.com/stuxnet999/MemLabs&quot;&gt;MemLabs&lt;/a&gt; and the Assembly Crash Course from the Practical Malware Analysis book, I was able to build a methodology for times I needed to hunt for malware and misused legitimate Windows processes inside memory captures.&lt;/p&gt;

&lt;p&gt;My first interactions with assembly and debuggers (especially WinDBG) was pretty much summed up:&lt;/p&gt;

&lt;figure class=&quot;&quot;&gt;
  &lt;img src=&quot;/assets/images/ecthpv2/whatthehellisthis.gif&quot; alt=&quot;&quot; /&gt;&lt;figcaption&gt;
      Featuring Dante from the Devil May Cry series™

    &lt;/figcaption&gt;&lt;/figure&gt;

&lt;p&gt;Last but not least, the course taught the fundamentals of YARA rule writing and using tools such as Loki which I found interesting. While I would find that the usage of YARA for threat hunters may not be as common as in security research and malware analysis (and real threat hunters are free to tell me I’m wrong about this), detection engineering does rely on writing and tuning effective rules to eliminate false positives, so this was a great exercise. Just like the law, YARA rules (and any other for that matter) can only be good as the people that written them!&lt;/p&gt;

&lt;p&gt;The learning experience helped a lot with nailing down the core concepts of hunting and several areas of blue team operations. It exaggerated several common attacks by threat actors to spot, and provided fundamental knowledge on research tools. In the next section, I will talk about my approach to the exam.&lt;/p&gt;

&lt;h2 id=&quot;exam&quot;&gt;Exam&lt;/h2&gt;
&lt;p&gt;The exam lasted 48 hours - during that time, I was expected to hunt through multiple scenarios, with and without TTPs and IOCs from threat intelligence, to gather every evidence possible and meet the objectives. For each threat that was discovered, you gained points whenever they were documented with provided steps to reproduce them.&lt;/p&gt;

&lt;p&gt;To make effective use of my time, I used the pomodoro technique (50 minutes of work and a 10 minute break) and took extra care to stay hydrated and eat meals. Every time I gotten stuck, I took a 5-10 minute break away from the screen, which resulted in several eureka moments and running back to the keyboard to test out the ideas! Having a normal sleep schedule was also paramount to keeping my mind in order and staying focused. While 48 hours may have seemed short to me on my first impression, I was able to complete it with time to spare and double-check all my findings were correct.&lt;/p&gt;

&lt;figure class=&quot;&quot;&gt;
  &lt;img src=&quot;/assets/images/ecthpv2/hydrate.png&quot; alt=&quot;&quot; /&gt;&lt;figcaption&gt;
      Follow what the frog says!

    &lt;/figcaption&gt;&lt;/figure&gt;

&lt;p&gt;I would recommend this approach to anyone else taking the exam. As long as you’ve completed most of the course modules and had some time to practise alone, you would be more than ready to ace it and know what to do when situations do not go according to plan. Despite the challenges, 2 days is more than enough to defeat the challenges brought by the eCTHPv2 exam.&lt;/p&gt;

&lt;h2 id=&quot;possible-improvements&quot;&gt;Possible Improvements&lt;/h2&gt;
&lt;p&gt;My overall experience from the delivery of eCTHPv2 was satisfying. If there were any improvements I would’ve suggested to make the lives of learners easier during their experience within the course though, it would be based on the following issues I faced:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Some of the labs did not work due to a bug - in this case, some labs needed VNC credentials to open a remote desktop session, and for some reason they did not work. This partially slowed down my studies and increased my preparation time for the exam.&lt;/li&gt;
  &lt;li&gt;There was also a catastrophic outage at some point which massively delayed my ability to take the exam. From what I can understand, INE (who had acquired eLearnSecurity back in 2020) was moving across their infrastructure to provide browser-based labs and retire VPNs. Their plans may have changed by now, as many people who used their platform heavily disapproved of their decision!&lt;/li&gt;
  &lt;li&gt;Long results wait times - I waited 35 days (24 business days) - while I understand that the reports were manually marked, waiting that long for my results somewhat dampened my hype! I heard people receiving results within &lt;em&gt;hours&lt;/em&gt; after submitting their reports for other exams, so it wasn’t great at all feeling my efforts were not rewarded the same way!&lt;/li&gt;
&lt;/ul&gt;

&lt;figure class=&quot;&quot;&gt;
  &lt;img src=&quot;/assets/images/ecthpv2/squidward.png&quot; alt=&quot;&quot; /&gt;&lt;figcaption&gt;
      

    &lt;/figcaption&gt;&lt;/figure&gt;

&lt;p&gt;Despite those mildly frustrating experiences, I look back now and remember how helpful the support team was (as usual), and the original course instructor was very friendly too! eCTHPv2 truly complemented other courses and interests I had, such as malware analysis, and ZeroPoint and Sektor7’s red team operations suites. The course may or may not have potential updates during the future depending on INE, but for someone taking it in the future I would recommend it. I would like to thank Slavi Parpulev for providing this awesome course!&lt;/p&gt;

&lt;p&gt;Thank you for reading my post, and I hope it was helpful for anyone who is taking is soon. If you have any questions about the course, feel free to reach out to me on any of my handles. During November I will be attempting the eCMAP exam as well, so keep an eye out for any study streams or new posts!&lt;/p&gt;</content><author><name>Malware Guy</name></author><category term="Course Reviews" /><category term="eCTHPv2" /><category term="Threat Hunting" /><category term="Course Reviews" /><summary type="html">I taken eCTHPv2 back in April, and eventually decided I wanted to write my personal thoughts and overall experience around the course!</summary></entry><entry><title type="html">Redline Stealer</title><link href="http://localhost:4000/Hunts/redline-stealer.html" rel="alternate" type="text/html" title="Redline Stealer" /><published>2022-09-09T00:00:00+01:00</published><updated>2022-09-09T00:00:00+01:00</updated><id>http://localhost:4000/Hunts/Redline-Stealer</id><content type="html" xml:base="http://localhost:4000/Hunts/redline-stealer.html">&lt;h2 id=&quot;intro&quot;&gt;Intro&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;For this hunt, I will be sharing my analysis notes and thought processes on how I approached the Redline Stealer malware, what I learned from reverse engineering it and how it given me an idea of what I can build upon the things that I currently know.&lt;/strong&gt; Here is some background on this malware family from Malpedia:&lt;/p&gt;

&lt;p&gt;&lt;em&gt;“RedLine Stealer is a malware available on underground forums for sale apparently as standalone ($100/$150 depending on the version) or also on a subscription basis ($100/month). This malware harvests information from browsers such as saved credentials, autocomplete data, and credit card information. A system inventory is also taken when running on a target machine, to include details such as the username, location data, hardware configuration, and information regarding installed security software. More recent versions of RedLine added the ability to steal cryptocurrency. FTP and IM clients are also apparently targeted by this family, and this malware has the ability to upload and download files, execute commands, and periodically send back information about the infected computer.”&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Recently, many content creators had been targeted by this particular malware campaign, abusing powerful and catastrophic yet publicly available tools (ahem, YouTube’s Copyright Claims system) to conduct cunning yet startlingly convincing attacks. I wanted to gain an understanding of the mechanics behind these attacks better through slightly lower level tools (as well as a great amount of improvising and frustration!) and techniques that can be used to handle crimeware.&lt;/p&gt;

&lt;p&gt;To start with the hunt, here were the tools I used:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Detect It Easy&lt;/li&gt;
  &lt;li&gt;CAPA 4&lt;/li&gt;
  &lt;li&gt;dnSpy&lt;/li&gt;
  &lt;li&gt;Process Hacker&lt;/li&gt;
  &lt;li&gt;x64dbg&lt;/li&gt;
  &lt;li&gt;PE Sieve&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;analysis&quot;&gt;Analysis&lt;/h2&gt;
&lt;h3 id=&quot;overlay-bytes&quot;&gt;Overlay Bytes&lt;/h3&gt;
&lt;p&gt;To evade sandboxes and antimalware, the original file contained an overlay, which caused it to be too big to analyse inside automated environments (&lt;a href=&quot;https://reverseengineering.stackexchange.com/a/2015&quot;&gt;reference&lt;/a&gt;).&lt;/p&gt;

&lt;figure class=&quot;&quot;&gt;
  &lt;img src=&quot;/assets/images/Redline/20220823191213.png&quot; alt=&quot;&quot; /&gt;&lt;figcaption&gt;
      The sample totals to 700MB, which can evade set file size limits within sandboxes and antimalware solutions

    &lt;/figcaption&gt;&lt;/figure&gt;

&lt;p&gt;Within Detect It Easy, the PE is shown to have its normal sections, as well as the bytes that prevent it from being analysed.&lt;/p&gt;

&lt;figure class=&quot;&quot;&gt;
  &lt;img src=&quot;/assets/images/Redline/20220823190601.png&quot; alt=&quot;&quot; /&gt;&lt;figcaption&gt;
      Rows of bytes consisting of 0x30 (0 in ASCII) lay dormant within the executable

    &lt;/figcaption&gt;&lt;/figure&gt;

&lt;p&gt;The below script can be used to strip the overlay bytes from the executable to bring it back close to its original size.&lt;/p&gt;

&lt;div class=&quot;language-py highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;pefile&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;sys&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;os&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;filename&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sys&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;argv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;sa&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;[*] Original file size: &lt;/span&gt;&lt;span class=&quot;si&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;os&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;path&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getsize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;filename&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;[*] Stripping overlay from file, standby...&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;pe&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pefile&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;PE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;filename&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;overlay&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;get_overlay_data_start_offset&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;strip_filename&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;filename&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;.strip&quot;&lt;/span&gt; 

&lt;span class=&quot;k&quot;&gt;with&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;open&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;filename&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;rb&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;read&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;overlay&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;with&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;open&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;strip_filename&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;wb&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;fp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;write&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;


&lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;sa&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;[*] Stripped file size: &lt;/span&gt;&lt;span class=&quot;si&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;os&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;path&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getsize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;strip_filename&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;sa&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;[*] New file is called &lt;/span&gt;&lt;span class=&quot;si&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;strip_filename&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;[+] Done!&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Alternatively, de4dot is capable of guessing the type of obfuscator used by the malware authors and removing the overlay, which I went with.&lt;/p&gt;

&lt;figure class=&quot;&quot;&gt;
  &lt;img src=&quot;/assets/images/Redline/20220827211430.png&quot; alt=&quot;&quot; /&gt;&lt;figcaption&gt;
      de4dot identified a possible obfuscator used and cleaned the overlay bytes as well as light obfuscation

    &lt;/figcaption&gt;&lt;/figure&gt;

&lt;h3 id=&quot;initial-triage&quot;&gt;Initial Triage&lt;/h3&gt;
&lt;p&gt;Searching through VirusTotal, there were no community comments at the time of investigation despite the sample having been uploaded there for a while. It was only known to be malicious by several AV engines.&lt;/p&gt;

&lt;figure class=&quot;&quot;&gt;
  &lt;img src=&quot;/assets/images/Redline/20220823175315.png&quot; alt=&quot;&quot; /&gt;&lt;figcaption&gt;
      Vendor results from VirusTotal

    &lt;/figcaption&gt;&lt;/figure&gt;

&lt;p&gt;Intezer however, was a different story. When running the sample inside its sandbox, it reported the following TTPs:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Code Injection - Process Hollowing&lt;/li&gt;
  &lt;li&gt;Trusted Developer Utilities Proxy Execution - &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;InstallUtil&lt;/code&gt; (&lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/framework/tools/installutil-exe-installer-tool&quot;&gt;https://docs.microsoft.com/en-us/dotnet/framework/tools/installutil-exe-installer-tool&lt;/a&gt;)&lt;/li&gt;
  &lt;li&gt;An attempted connection to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;65[.]21[.]74[.]139&lt;/code&gt; (inactive at the time of the investigation) via a non-standard port&lt;/li&gt;
  &lt;li&gt;Launches PowerShell with an encoded command&lt;/li&gt;
&lt;/ul&gt;

&lt;figure class=&quot;&quot;&gt;
  &lt;img src=&quot;/assets/images/Redline/20220823185117.png&quot; alt=&quot;&quot; /&gt;&lt;figcaption&gt;
      TTPs as well as their techniques, severity ratings and further details were identified in Intezer

    &lt;/figcaption&gt;&lt;/figure&gt;

&lt;p&gt;As expected, all platforms also reported that the implant steals credentials. At this point, it was time to investigate within dnSpy.&lt;/p&gt;

&lt;h3 id=&quot;anti-debugging-dnspy&quot;&gt;Anti-Debugging (dnSpy)&lt;/h3&gt;
&lt;p&gt;After loading the sample into dnSpy, I found that its classes and objects had very deceptive names (surprise, surprise in crimeware). After attempting to run it, the sample halted its execution due to the presence of the debugger.&lt;/p&gt;

&lt;figure class=&quot;&quot;&gt;
  &lt;img src=&quot;/assets/images/Redline/20220823233012.png&quot; alt=&quot;&quot; /&gt;&lt;figcaption&gt;
      An anti-debugging technique was used to slow down dynamic analysis

    &lt;/figcaption&gt;&lt;/figure&gt;

&lt;p&gt;This Redline sample detected dnSpy through dynamically imported functions, and to deal with this, I patched the IL assembly instruction for the line of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;if (ImageInvoker.DisableReference())&lt;/code&gt; - the new logic of the expression was that if the sample detects the debugger, it runs. Reverse &lt;del&gt;engineering&lt;/del&gt; psychology, right?&lt;/p&gt;

&lt;figure class=&quot;&quot;&gt;
  &lt;img src=&quot;/assets/images/Redline/20220824193908.png&quot; alt=&quot;&quot; /&gt;&lt;figcaption&gt;
      The original logic of the expression within the IL instructions was &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bfalse.s&lt;/code&gt;, before it got reversed to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;btrue.s&lt;/code&gt; through patching

    &lt;/figcaption&gt;&lt;/figure&gt;

&lt;p&gt;After saving the module, the implant worked perfectly.&lt;/p&gt;

&lt;h3 id=&quot;hunting-for-the-payload&quot;&gt;Hunting for the payload&lt;/h3&gt;
&lt;p&gt;After scouting through the executable, I found an abnormally long series of bytes which even dnSpy couldn’t process them all.&lt;/p&gt;

&lt;figure class=&quot;&quot;&gt;
  &lt;img src=&quot;/assets/images/Redline/20220828141801.png&quot; alt=&quot;&quot; /&gt;&lt;figcaption&gt;
      Noticing an array of bytes present within the C#

    &lt;/figcaption&gt;&lt;/figure&gt;

&lt;figure class=&quot;&quot;&gt;
  &lt;img src=&quot;/assets/images/Redline/20220828141830.png&quot; alt=&quot;&quot; /&gt;&lt;figcaption&gt;
      …10000+ lines later

    &lt;/figcaption&gt;&lt;/figure&gt;

&lt;p&gt;It was like staring down an elephant inside the room! I set a breakpoint at the caller so I can extract it from memory. It was 509KB in total.&lt;/p&gt;

&lt;figure class=&quot;&quot;&gt;
  &lt;img src=&quot;/assets/images/Redline/20220828140940.png&quot; alt=&quot;&quot; /&gt;&lt;figcaption&gt;
      Chucking a Pokéball at the payload in memory

    &lt;/figcaption&gt;&lt;/figure&gt;

&lt;p&gt;After decompressing the gzip data with CyberChef, the payload was found to be indeed a .NET-based PE. However, it was heavily obfuscated. de4dot was unable to detect which obfuscator was used on it as well.&lt;/p&gt;

&lt;figure class=&quot;&quot;&gt;
  &lt;img src=&quot;/assets/images/Redline/20220828142211.png&quot; alt=&quot;&quot; /&gt;&lt;figcaption&gt;
      .NET assembly found in memory, containing obfuscated namespaces, classes and methods

    &lt;/figcaption&gt;&lt;/figure&gt;

&lt;h3 id=&quot;exploring-process-hollowing&quot;&gt;Exploring Process Hollowing&lt;/h3&gt;
&lt;figure class=&quot;&quot;&gt;
  &lt;img src=&quot;/assets/images/Redline/6sru1r.jpg&quot; alt=&quot;&quot; /&gt;&lt;figcaption&gt;
      Definitely not a generated meme

    &lt;/figcaption&gt;&lt;/figure&gt;

&lt;p&gt;&lt;strong&gt;I wanted to explore process hollowing as it happened at code level&lt;/strong&gt;, but given that the code of the payload was heavily obfuscated, viewing the unmanaged calls through dnSpy proven difficult.&lt;/p&gt;

&lt;p&gt;Some of my wild guesses were:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;.NET and PowerShell abuse &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;System.Reflection.Assembly.Load&lt;/code&gt; - the process hollowing may have been happening through the invoked .NET assembly, so it may bave been best to set a breakpoint at this function and extract .NET assemblies from there. The &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ImageDictionary&lt;/code&gt; class was likely responsible for this.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;I noticed that the sample killed its own process prior to starting &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;InstallUtil&lt;/code&gt;. I set a breakpoint at various functions I believed the malware used (including &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Process.WaitForExit&lt;/code&gt;), and after a bit (hours, actually) of stepping through the code inside the debugger and observing the call stack, here was an example of what I seen:&lt;/p&gt;

&lt;figure class=&quot;&quot;&gt;
  &lt;img src=&quot;/assets/images/Redline/20220828123648.png&quot; alt=&quot;&quot; /&gt;&lt;figcaption&gt;
      Call stack of the functions called before &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Process.WaitForExit&lt;/code&gt;

    &lt;/figcaption&gt;&lt;/figure&gt;

&lt;p&gt;Quite the mess! Trying to analyse the obfuscated .NET assembly in dnSpy was a difficult task, so in the end I opted for continuing the dynamic analysis through x64dbg as the executable will eventually remove its own obfuscation once it is fully loaded in memory.&lt;/p&gt;

&lt;p&gt;I’m aware that process hollowing uses the following APIs, which I set breakpoints for (as well as their counterparts) inside x64dbg, the ones in bold being prioritised due to them containing arguments related to what was seen in the TTPs:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CreateProcess&lt;/code&gt;&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ZwUnmapViewOfSection&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;VirtualAllocEx&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;WriteProcessMemory&lt;/code&gt;&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SetThreadContext&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ResumeThread&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;This is a classic pattern of process hollowing to make room for the malicious process, launching a legitimate Windows executable and using it as a sacrifical lamb to hide from security tools that lack the capability to detect and prevent malicious usage of these APIs. In the below sections. I was able to catch a few calls to a number of calls on some breakpoints.&lt;/p&gt;

&lt;h4 id=&quot;createprocessw&quot;&gt;CreateProcessW&lt;/h4&gt;
&lt;p&gt;After a lot of trial and error, the first breakpoint that caught my eye was a call to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CreateProcessW&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;&quot;&gt;
  &lt;img src=&quot;/assets/images/Redline/20220905185146.png&quot; alt=&quot;&quot; /&gt;&lt;figcaption&gt;
      First call made to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CreateProcessW&lt;/code&gt;

    &lt;/figcaption&gt;&lt;/figure&gt;

&lt;p&gt;One of its arguments within the stack aimed to execute 64-bit PowerShell, along with a Base64-encoded command that causes the console to sleep for 10 seconds. Unimportant, but still one of the TTPs and a way to identify similar behaviour.&lt;/p&gt;

&lt;figure class=&quot;&quot;&gt;
  &lt;img src=&quot;/assets/images/Redline/20220905185218.png&quot; alt=&quot;&quot; /&gt;&lt;figcaption&gt;
      As seen in the stack

    &lt;/figcaption&gt;&lt;/figure&gt;

&lt;p&gt;The full command line can be as seen in Process Hacker:&lt;/p&gt;

&lt;figure class=&quot;&quot;&gt;
  &lt;img src=&quot;/assets/images/Redline/20220905185540.png&quot; alt=&quot;&quot; /&gt;&lt;/figure&gt;

&lt;h4 id=&quot;createprocessa&quot;&gt;CreateProcessA&lt;/h4&gt;
&lt;p&gt;As expected, the malware eventually made a call to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CreateProcessA&lt;/code&gt; that requested the Windows API to start a suspended process with the image of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;InstallUtil&lt;/code&gt;. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ZwUnmapViewOfSection&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;VirtualAllocEx&lt;/code&gt; calls targeting &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;InstallUtil&lt;/code&gt; followed not long after, removing all executable instructions of the original PE image and allocating space for the payload to be injected.&lt;/p&gt;

&lt;figure class=&quot;&quot;&gt;
  &lt;img src=&quot;/assets/images/Redline/20220905180455.png&quot; alt=&quot;&quot; /&gt;&lt;figcaption&gt;
      First breakpoint at &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CreateProcessA&lt;/code&gt;

    &lt;/figcaption&gt;&lt;/figure&gt;

&lt;figure class=&quot;&quot;&gt;
  &lt;img src=&quot;/assets/images/Redline/20220905180702.png&quot; alt=&quot;&quot; /&gt;&lt;figcaption&gt;
      Command line presented to the function

    &lt;/figcaption&gt;&lt;/figure&gt;

&lt;p&gt;Below shows the strings of the original executable in memory before the injection and the parent-child relationship between the processes:&lt;/p&gt;

&lt;figure class=&quot;&quot;&gt;
  &lt;img src=&quot;/assets/images/Redline/20220905180824.png&quot; alt=&quot;&quot; /&gt;&lt;figcaption&gt;
      Normal strings expected within the executable

    &lt;/figcaption&gt;&lt;/figure&gt;

&lt;figure class=&quot;&quot;&gt;
  &lt;img src=&quot;/assets/images/Redline/20220905180848.png&quot; alt=&quot;&quot; /&gt;&lt;figcaption&gt;
      The sample presented itself as the parent process for &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;InstallUtil&lt;/code&gt; - this can be helpful when hunting for IOCs through SIEMs

    &lt;/figcaption&gt;&lt;/figure&gt;

&lt;h4 id=&quot;writeprocessmemory&quot;&gt;WriteProcessMemory&lt;/h4&gt;
&lt;p&gt;Finally, it was the Windows API call we had all been waiting for - &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;WriteProcessMemory&lt;/code&gt;! Being able to catch a payload as it is being written to a target (whether it’s a file, process or network destination) is a crucial part of the analysis; in this case I am simply retrieving the evidence that a write operation is taking place. Below, the API in question as well as the PE header of the payload was spotted in x64dbg.&lt;/p&gt;

&lt;figure class=&quot;&quot;&gt;
  &lt;img src=&quot;/assets/images/Redline/20220905181226.png&quot; alt=&quot;&quot; /&gt;&lt;figcaption&gt;
      &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;WriteProcessMemory&lt;/code&gt; as well as the parameters passed to it on the stack

    &lt;/figcaption&gt;&lt;/figure&gt;

&lt;p&gt;Seeing the PE header in the stack gave the impression something cool was probably happening and worth watching! I allowed the program to run the function until it had returned a couple of times and completed its transfer of data.&lt;/p&gt;

&lt;figure class=&quot;&quot;&gt;
  &lt;img src=&quot;/assets/images/Redline/20220905181217.png&quot; alt=&quot;&quot; /&gt;&lt;figcaption&gt;
      Spotting a partial chunk of the PE within the dump

    &lt;/figcaption&gt;&lt;/figure&gt;

&lt;p&gt;Process Hacker also displayed corresponding results about the injection taking place within the new process.&lt;/p&gt;

&lt;figure class=&quot;&quot;&gt;
  &lt;img src=&quot;/assets/images/Redline/20220905182542.png&quot; alt=&quot;&quot; /&gt;&lt;figcaption&gt;
      Query strings, file paths and more slightly obfuscated data relating to credential stores present in memory

    &lt;/figcaption&gt;&lt;/figure&gt;

&lt;p&gt;The next calls to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SetThreadContext&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ResumeThread&lt;/code&gt; would then set the entry point to the new code section and take the process out of suspended state, hence proving the proxy execution of a trusted developer utility.&lt;/p&gt;

&lt;p&gt;In other targeted campaigns, I would imagine malware authors would go through a lot more effort to hide strings in memory, especially from tools such as EDRs. Several of them were found in plaintext relating to software file paths, password databases and query strings which indicates successful code injection has taken place, and the final Redline payload is now running and attempting to steal personal information.&lt;/p&gt;

&lt;p&gt;Seeing those strings, it was about time to dump the payload from memory.&lt;/p&gt;

&lt;h3 id=&quot;dumping-the-injected-pe&quot;&gt;Dumping the injected PE&lt;/h3&gt;
&lt;figure class=&quot;&quot;&gt;
  &lt;img src=&quot;/assets/images/Redline/online-classes-throw-away.gif&quot; alt=&quot;&quot; /&gt;&lt;figcaption&gt;
      Aggressively tossing out the malware from memory

    &lt;/figcaption&gt;&lt;/figure&gt;

&lt;p&gt;Given the process hollowing technique was used to inject the payload into &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;InstallUtil&lt;/code&gt;, I used PE Sieve to extract the malware. PE Sieve is a powerful tool for detecting processes that were targeted in a potential code injection attack, dumping replaced or injected PEs, shellcode, hooks and other in-memory patches from memory and saving them into a file readily available for analysis.&lt;/p&gt;

&lt;figure class=&quot;&quot;&gt;
  &lt;img src=&quot;/assets/images/Redline/20220905184117.png&quot; alt=&quot;&quot; /&gt;&lt;figcaption&gt;
      PE Sieve detected 1 occurrence of malicious code and dumped it into a new file

    &lt;/figcaption&gt;&lt;/figure&gt;

&lt;p&gt;Of course, resulting threat intelligence tells that this executable is related to the Redline Stealer campaign due to code reuse.&lt;/p&gt;

&lt;figure class=&quot;&quot;&gt;
  &lt;img src=&quot;/assets/images/Redline/20220828203748.png&quot; alt=&quot;&quot; /&gt;&lt;figcaption&gt;
      The payload as seen in VirusTotal, it was also recognised by the signatures within Florian Roth’s tool

    &lt;/figcaption&gt;&lt;/figure&gt;

&lt;figure class=&quot;&quot;&gt;
  &lt;img src=&quot;/assets/images/Redline/20220828203841.png&quot; alt=&quot;&quot; /&gt;&lt;figcaption&gt;
      Threat intelligence as shown in Intezer

    &lt;/figcaption&gt;&lt;/figure&gt;

&lt;h4 id=&quot;wsaconnect&quot;&gt;WSAConnect&lt;/h4&gt;
&lt;p&gt;The payload itself was a portable executable, which could still be run alone. It was responsible for connecting to the command and control server as well as extracting and marshalling credentials and banking information to send back. Different command and control servers use a variety of protocols such as HTTP/S, DNS and IRC (ah, good old days!). Occasionally, threat actors write their own custom C2 protocols which do not adhere to the transmission rules of a well known service associated with their assigned port, and in turn can increase analysis time if it is not already known within threat intelligence, and circumvent firewall rules within organisations. In this case, the Redline sample attempted to connect back to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;65[.]21[.]74[.]139&lt;/code&gt; on port 20775, and for that it required the Win32 APIs.&lt;/p&gt;

&lt;p&gt;MSDN described &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;WSAConnect&lt;/code&gt; as one of the functions responsible for creating a network connection to IPv4 and IPv6 hosts. What I was most interested in was &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;name&lt;/code&gt; - this parameter contained the address pointing to the variable that held the string of the C2 address within this malware.&lt;/p&gt;

&lt;figure class=&quot;&quot;&gt;
  &lt;img src=&quot;/assets/images/Redline/20220909004308.png&quot; alt=&quot;&quot; /&gt;&lt;figcaption&gt;
      The target here was to identify the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;name&lt;/code&gt; parameter, which is a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;socketaddr&lt;/code&gt; struct that contained the IP address of the C2 server

    &lt;/figcaption&gt;&lt;/figure&gt;

&lt;p&gt;After following the stack and sequentially the DWORD for the pointer within the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;name&lt;/code&gt; parameter, the IP address of the command and control server was located within the memory dump.&lt;/p&gt;

&lt;figure class=&quot;&quot;&gt;
  &lt;img src=&quot;/assets/images/Redline/20220909002940.png&quot; alt=&quot;&quot; /&gt;&lt;figcaption&gt;
      The sequence of bytes containing the address pointing to the parameter I was looking for

    &lt;/figcaption&gt;&lt;/figure&gt;

&lt;figure class=&quot;&quot;&gt;
  &lt;img src=&quot;/assets/images/Redline/20220909003011.png&quot; alt=&quot;&quot; /&gt;&lt;figcaption&gt;
      The IP address of the C2 as seen in the dump

    &lt;/figcaption&gt;&lt;/figure&gt;

&lt;h3 id=&quot;iocs&quot;&gt;IOCs&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Original SHA256:
b4781474596c183da5b10c22ce2260c802ef4f553ed347f4813ad30cab0d56e2

Stripped SHA256:
62B06D71CD6403A1E2DB56E498A5A8B14B6908F5DDFEC9FA4D5F49F6F4A70678

65[.]21[.]74[.]139

Process Creation - &quot;C:\\Windows\\System32\\WindowsPowerShell\v1.0\\powershell.exe&quot; -enc UwB0AGEAcgB0AC0AUwBsAGUAZQBwACAALQBTAGUAYwBvAG4AZABzACAAMQAwAA==

Process Creation - C:\\Windows\\Microsoft.NET\\Framework\\v4.0.30319\\InstallUtil.exe

Injected payload SHA256:
16263ec84e6175336debb2da5fda9560236b1ce00bf2eec1e2bb5714a9ce3430
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;references&quot;&gt;References&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://malpedia.caad.fkie.fraunhofer.de/details/win.redline_stealer&quot;&gt;https://malpedia.caad.fkie.fraunhofer.de/details/win.redline_stealer&lt;/a&gt;
&lt;a href=&quot;https://tria.ge/220705-zwf3dsdaaq&quot;&gt;https://tria.ge/220705-zwf3dsdaaq&lt;/a&gt;
&lt;a href=&quot;https://www.virustotal.com/gui/file/62b06d71cd6403a1e2db56e498a5a8b14b6908f5ddfec9fa4d5f49f6f4a70678&quot;&gt;https://www.virustotal.com/gui/file/62b06d71cd6403a1e2db56e498a5a8b14b6908f5ddfec9fa4d5f49f6f4a70678&lt;/a&gt;
&lt;a href=&quot;https://analyze.intezer.com/analyses/6146f62d-9f78-4e38-b944-b62daa82ade7/&quot;&gt;https://analyze.intezer.com/analyses/6146f62d-9f78-4e38-b944-b62daa82ade7/&lt;/a&gt;
&lt;a href=&quot;https://www.virustotal.com/gui/file/16263ec84e6175336debb2da5fda9560236b1ce00bf2eec1e2bb5714a9ce3430&quot;&gt;https://www.virustotal.com/gui/file/16263ec84e6175336debb2da5fda9560236b1ce00bf2eec1e2bb5714a9ce3430&lt;/a&gt;
&lt;a href=&quot;https://analyze.intezer.com/analyses/a3ba1334-11b9-4534-934d-f17f6c501c69&quot;&gt;https://analyze.intezer.com/analyses/a3ba1334-11b9-4534-934d-f17f6c501c69&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;vmprotected-variant&quot;&gt;VMProtected Variant&lt;/h2&gt;
&lt;p&gt;While nearly finishing the unpacked variant, I decided to have a brief look at the one John Hammond mentioned in his &lt;a href=&quot;https://twitter.com/_JohnHammond/status/1564271069514563586&quot;&gt;Twitter status&lt;/a&gt; too. As I am still learning the ropes of unpacking malware in different circumstances, I want to re-visit this on a future occasion!&lt;/p&gt;

&lt;h3 id=&quot;initial-triage-1&quot;&gt;Initial Triage&lt;/h3&gt;
&lt;p&gt;Pretty much the same principles applied to getting rid of the overlay. It went down from 471MB to a mere 600KB.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Original SHA256: f8df7a34f17242157f9095b4aa05740c7ea9769bacd766cb1b0eac817a52455b

Stripped SHA256: 514eef525b97f3e00ff6f4bc60955c0fe0a5ff74d5996b448e80e6eef699c5ed
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;figure class=&quot;&quot;&gt;
  &lt;img src=&quot;/assets/images/Redline/20220904130434.png&quot; alt=&quot;&quot; /&gt;&lt;figcaption&gt;
      Detect It Easy indicates the sample was packed with VMProtect 3.2-3.5 through its import hashes

    &lt;/figcaption&gt;&lt;/figure&gt;

&lt;figure class=&quot;&quot;&gt;
  &lt;img src=&quot;/assets/images/Redline/20220830194457.png&quot; alt=&quot;&quot; /&gt;&lt;figcaption&gt;
      CAPA 4 particularly didn’t enjoy being fed this sample (who would with any malware really?), probably most likely due to VMProtect 3

    &lt;/figcaption&gt;&lt;/figure&gt;

&lt;h3 id=&quot;assumptions-for-future-analysis&quot;&gt;Assumptions for Future Analysis&lt;/h3&gt;
&lt;p&gt;Because there is a lot of threat intelligence and analysis on Redline, many of its behaviours had been already documented and there would be a great number of assumptions to make when re-exploring this variant:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Reading files and registry keys - due to its nature of accessing password databases and files, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ReadFile&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;RegOpenKey&lt;/code&gt; will be most likely used&lt;/li&gt;
  &lt;li&gt;Internet Connections - it tries to connect back to C2 servers, and the connections can be emulated. Some Windows API functions for this include &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;WSAConnect&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;WSASocketW&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;These functionalities would be enough to consider setting breakpoints at and exploring when I unpack this variant.&lt;/p&gt;

&lt;p&gt;Another assumption to make is that some or many of its functions would need to be devirtualised due to it being packed by VMProtect, and if I wanted to make the executable runnable again I would need to fix the original entry point and the import address table. In the real world, there would be a high chance I would use automated tools such as UnpacMe to extract the payload, but it would be great to have some practise unpacking manually as well.&lt;/p&gt;

&lt;h2 id=&quot;threat-intelligence&quot;&gt;Threat Intelligence&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://tria.ge/220829-ray23sbdh9&quot;&gt;https://tria.ge/220829-ray23sbdh9&lt;/a&gt;
&lt;a href=&quot;https://www.virustotal.com/gui/file/514eef525b97f3e00ff6f4bc60955c0fe0a5ff74d5996b448e80e6eef699c5ed&quot;&gt;https://www.virustotal.com/gui/file/514eef525b97f3e00ff6f4bc60955c0fe0a5ff74d5996b448e80e6eef699c5ed&lt;/a&gt;
&lt;a href=&quot;https://analyze.intezer.com/analyses/cd7437cf-35f9-4804-93bf-186362abd9b1&quot;&gt;https://analyze.intezer.com/analyses/cd7437cf-35f9-4804-93bf-186362abd9b1&lt;/a&gt;
&lt;a href=&quot;https://www.joesandbox.com/analysis/695059/0/html&quot;&gt;https://www.joesandbox.com/analysis/695059/0/html&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;ending-thoughts&quot;&gt;Ending Thoughts&lt;/h2&gt;
&lt;p&gt;Investigating this sample had unearthed some skills that laid dormant in my arsenal for a very long time, and it allowed me to experiment with things that worked and did not work. I had a lot of fun working on this, going some of the extra miles with what I currently know in this hunt may not have been practical in the real world (malware reports are more focused on exposing immediate effects of malware rather than verbose steps on how to expose them) but they can come in handy on future occasions. There were a few things that I learned:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Overlays within malware - to be honest, I was surprised when I saw that this technique worked to bypass protections, but it works. Because of this flaw combined with an innocent Microsoft Office icon and convincing document title, unsuspecting victims who had been sent similar malware with no intervention from their antimalware solutions would have been impacted by this campaign&lt;/li&gt;
  &lt;li&gt;Evading anti-debugging - patching the logic of this sample was exceptionally easy, especially since the malware authors did not put that much effort into preventing further analysis on it. However, that was not to say that I was unable to explore with a bit of trial and error on amending the IL instructions and source code!&lt;/li&gt;
  &lt;li&gt;Understanding when to switch tools or techniques - dnSpy was definitely a good choice for static analysis on the executable before it performed code injection attacks, but made terribly for dynamic analysis especially since native APIs were outside of its scope. With x64dbg, it was possible to monitor the calls made to these APIs and see the attack happening in real time, and I would be able to save time rather than attempting to deobfuscate and understand the malware behaviour by myself!&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Hopefully this post was easy and comprehensive for other beginners who are also keen on getting into malware analysis. I’m looking forward to taking on more challenges!&lt;/p&gt;

&lt;p&gt;Thank you for reading, if you want to talk about this post or have any questions feel free to reach out to me on any of my social media handles.&lt;/p&gt;

&lt;h2 id=&quot;shoutouts&quot;&gt;Shoutouts&lt;/h2&gt;
&lt;p&gt;This exercise was made possible thanks to &lt;a href=&quot;https://twitter.com/HuskyHacksMK&quot;&gt;HuskyHacks&lt;/a&gt;, check his social media out!&lt;/p&gt;

&lt;p&gt;Also check out &lt;a href=&quot;https://www.twitter.com/billycontra&quot;&gt;billycontra&lt;/a&gt;, this awesome individual proofread my endeavors and provided some helpful advice before it went live!&lt;/p&gt;</content><author><name>Malware Guy</name></author><category term="Hunts" /><category term="Redline Stealer" /><category term="Detect It Easy" /><category term="CAPA" /><category term="dnSpy" /><category term="Process Hacker" /><category term="x64dbg" /><category term="PE Sieve" /><summary type="html">Intro For this hunt, I will be sharing my analysis notes and thought processes on how I approached the Redline Stealer malware, what I learned from reverse engineering it and how it given me an idea of what I can build upon the things that I currently know. Here is some background on this malware family from Malpedia:</summary></entry></feed>